
# **Reading Notes: API Deployment**


## Why are these reading important?

```
Better settings configuration will eleviate a lot of development headaches. Using Whitenoise to serve your applications static files will also make things easier in the long run. While understanding CORS will make your user's data more secure.
```


---

## [**Django Settings Best Practices:**](https://djangostars.com/blog/configuring-django-settings-best-practices/)


---

## [**White Noise:**](http://whitenoise.evans.io/en/stable/)


---

## [**CORS:**](https://en.m.wikipedia.org/wiki/Cross-origin_resource_sharing)


---

## READING QUESTIONS:


	1. Prompt: What are the key principles to follow when organizing and configuring Django settings for a project, according to the “Django Settings Best Practices” reading?

		Solution:
		1.1. Maintain different settings for different environments such a local, development, staging, and production.

```bash
settings/
├── __init__.py
├── base.py
├── ci.py
├── local.py
├── staging.py
├── production.py
└── qa.py
```

```bash
python manage.py runserver --settings=settings.local
```

		1.2. Don't store sensitive data in settings. The following is how to do this manually with os or with django-environ

```python
# project/settings.py
# with os
import os
from django.core.exceptions import ImproperlyConfigured

def get_env_value(env_variable):
    try:
      	return os.environ[env_variable]
    except KeyError:
        error_msg = 'Set the {} environment variable'.format(var_name)
        raise ImproperlyConfigured(error_msg)


SECRET_KEY = get_env_value('SECRET_KEY')
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': get_env_value('DATABASE_NAME'),
        'HOST': get_env_value('DATABASE_HOST'),
        'PORT': int(get_env_value('DATABASE_PORT')),
    }
}
```

```python
# project/settings.py
# with django-envrion
import environ

root = environ.Path(__file__) - 3  # get root of the project
env = environ.Env()
environ.Env.read_env()  # reading .env file

SITE_ROOT = root()

DEBUG = env.bool('DEBUG', default=False)
TEMPLATE_DEBUG = DEBUG

DATABASES = {'default': env.db('DATABASE_URL')}

public_root = root.path('public/')
MEDIA_ROOT = public_root('media')
MEDIA_URL = env.str('MEDIA_URL', default='media/')
STATIC_ROOT = public_root('static')
STATIC_URL = env.str('STATIC_URL', default='static/')

SECRET_KEY = env.str('SECRET_KEY')

CACHES = {'default': env.cache('REDIS_CACHE_URL')}
```

```python
# .env
DEBUG=True
DATABASE_URL=postgres://user:password@db.example.com:5432/production_db?sslmode=require
REDIS_CACHE_URL=redis://user:password@cache.example.com:6379/1
SECRET_KEY=Some-Autogenerated-Secret-Key
```

		1.3. Optional to split settings by source rather than environment.
```bash
project/
├── apps/
├── settings/
│   ├── project
│   │   ├── __init__.py
│   │   ├── custom_module_foo.py
│   │   ├── custom_module_bar.py
│   │   └── custom_module_xyz.py
│   ├── third_party
│   │   ├── __init__.py
│   │   ├── celery.py
│   │   ├── email.py
│   │   └── rest_framework.py
│   ├── __init__.py
│   └── djano.py
└── manage.py
```



	2. Prompt: How does the White Noise library contribute to the efficient serving of static files in a Django application, and what are the steps to integrate it into a project?

		Solution: Whitenoise is a middleware library that enables the serving of static files during development or production. It accomplishes this through a combination of compression, caching, and integration with backend storage.

		2.1. Pip install whitenoise. 
```bash
pip install whitenoise
```
		2.2. Update project/settings.py
```python
MIDDLEWARE = [
		"django.middleware.security.SecurityMiddleware",
    'whitenoise.middleware.WhiteNoiseMiddleware',	#new
]
STATIC_URL = '/static/'	#new
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'	#new
```
		2.3. Collect static files using whitenoise.
```bash
python manage.py collectstatic
```


	3. Prompt: What is the purpose of Cross-Origin Resource Sharing (CORS) in web applications, and how can it be implemented and configured in a Django project to control access to resources?

		Solution: It is a security feature implemented by a client browser to control how web pages can request and interact with other urls. The intent is to prevent malicious urls/apis/webpages from stealing user data and potentially impersonating the user.

		We can leverage the Django CORS Headers library to automate this task for us.
		
		3.1 Install library.

```bash
pip install django-cors-headers
```

		3.2 Update project/settings.

```python
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',	#new
]
INSTALLED_APPS = [
    'corsheaders',	#new
]
CORS_ALLOWED_ORIGINS = [
    "https://",	# frontend url
    "http://",  # development url
]
```

		3.3 User corsheaders' decorators with your views.
	
```python
from corsheaders.decorators import cors_allow_all

@cors_allow_all  # any number of others available
def view(request):
```

---

## **What I want to learn more about:**

	1. I hear a lot of making whitenoise more performant in production through the use of CDN or Nginx. I need to understand what is meant by this.

---
---
---
